"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:true});exports.InOrbit=exports.Logger=void 0;var _regenerator=_interopRequireDefault(require("@babel/runtime/regenerator"));var _classPrivateFieldGet2=_interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldGet"));var _classPrivateFieldSet2=_interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldSet"));var _typeof2=_interopRequireDefault(require("@babel/runtime/helpers/typeof"));var _asyncToGenerator2=_interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _classCallCheck2=_interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2=_interopRequireDefault(require("@babel/runtime/helpers/createClass"));var _axios=_interopRequireDefault(require("axios"));var _asyncMqtt=_interopRequireDefault(require("async-mqtt"));var _inorbit_pb=_interopRequireDefault(require("./inorbit_pb"));function _classPrivateMethodInitSpec(obj,privateSet){_checkPrivateRedeclaration(obj,privateSet);privateSet.add(obj)}function _classPrivateFieldInitSpec(obj,privateMap,value){_checkPrivateRedeclaration(obj,privateMap);privateMap.set(obj,value)}function _checkPrivateRedeclaration(obj,privateCollection){if(privateCollection.has(obj)){throw new TypeError("Cannot initialize the same private elements twice on an object")}}function _classPrivateMethodGet(receiver,privateSet,fn){if(!privateSet.has(receiver)){throw new TypeError("attempted to get private field on non-instance")}return fn}var EDGE_SDK_VERSION="0.1.0";var INORBIT_ENDPOINT_DEFAULT="https://control.inorbit.ai/cloud_sdk_robot_config";// Agent version reported when a robot connection is open using this SDK
var AGENT_VERSION="".concat(EDGE_SDK_VERSION,".edgesdk");// MQTT Topics
var MQTT_TOPIC_CUSTOM_DATA="custom";var MQTT_TOPIC_LOCALIZATION="ros/loc/data2";var MQTT_TOPIC_ODOMETRY="ros/odometry/data";/**
 * RobotSession represent the session of a robot connected to InOrbit from the
 * point of view of the robot end. Technically this is a facade that provides
 * a clean interface to the InOrbit Robot Protocol.
 */var RobotSession=/*#__PURE__*/function(){/**
   * Initializes a robot session.
   *
   * Note that the session isn't automatically connected. You must call `connect`
   * before publishing any message.
   *
   * @typedef {Settings}
   * @property {string} appKey
   * @property {string} endpoint URL of the HTTP endpoint to fetch
   * robots settings.
   *
   * @param {string} robotId
   * @param {string} name
   * @param {Settings}
   */function RobotSession(_ref){var robotId=_ref.robotId,_ref$name=_ref.name,name=_ref$name===void 0?"unknown":_ref$name;var settings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};(0,_classCallCheck2["default"])(this,RobotSession);this.robotId=robotId;this.name=name;this.agentVersion=AGENT_VERSION;this.appKey=settings.appKey;this.endpoint=settings.endpoint;this.logger=settings.logger}/**
   * Fetches the configuration for this robot session based on its robotId and
   * appKey
   *
   * @returns {Object} Robot configuration
   */(0,_createClass2["default"])(RobotSession,[{key:"fetchRobotConfig",value:function(){var _fetchRobotConfig=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee(){var params,response;return _regenerator["default"].wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:this.logger.info("Fetching config for robot ".concat(this.robotId," for appKey ").concat(this.appKey.substr(0,3),"..."));params={appKey:this.appKey,robotId:this.robotId,hostname:this.name,agentVersion:this.agentVersion};_context.next=4;return _axios["default"].post(this.endpoint,params);case 4:response=_context.sent;if(!(response.status!=200||!response.data)){_context.next=7;break}throw Error("Failed to fetch config for robot ".concat(this.robotId));case 7:return _context.abrupt("return",response.data);case 8:case"end":return _context.stop();}}},_callee,this)}));function fetchRobotConfig(){return _fetchRobotConfig.apply(this,arguments)}return fetchRobotConfig}()/**
   * Connects to the InOrbit Platform
   */},{key:"connect",value:function(){var _connect=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee2(){var mqttConfig,protocol,hostname,port,username,password,robotApiKey;return _regenerator["default"].wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this.fetchRobotConfig();case 2:mqttConfig=_context2.sent;protocol=mqttConfig.protocol,hostname=mqttConfig.hostname,port=mqttConfig.port,username=mqttConfig.username,password=mqttConfig.password,robotApiKey=mqttConfig.robotApiKey;_context2.next=6;return _asyncMqtt["default"].connect(protocol+hostname+":"+port,{username:username,password:password,will:{topic:"r/".concat(this.robotId,"/state"),payload:"0|".concat(robotApiKey),qos:1,retain:true}});case 6:this.mqtt=_context2.sent;if(this.ended){// In case this session was ended by end() while it was connecting
this.mqtt.end()}// TODO(mike) handle errors
this.robotApiKey=robotApiKey;return _context2.abrupt("return",this.publish("state","1|".concat(robotApiKey,"|").concat(this.agentVersion,"|").concat(this.name),{qos:1,retain:true}));case 10:case"end":return _context2.stop();}}},_callee2,this)}));function connect(){return _connect.apply(this,arguments)}return connect}()/**
   * Ends session, disconnecting from cloud services
   */},{key:"end",value:function end(){// Before ending the session, update robot state explicitly as the `will` configured
// on the mqtt `connect` method is trigged only if the "client disconnect badly"
this.logger.info("Setting robot ".concat(this.robotId," state as offline"));this.publish("state","0|".concat(this.robotApiKey,"|").concat(this.agentVersion,"|").concat(this.name),{qos:1,retain:true});this.ended=true;this.mqtt&&this.mqtt.end()}/**
   * Publishes a string or Buffer message
   * @param {string} topic
   * @param {string|Buffer} msg
   * @param {Object} options
   */},{key:"publish",value:function publish(topic,msg,options){return this.mqtt.publish("r/".concat(this.robotId,"/").concat(topic),msg,options)}/**
   * Publishes a a custom data message containing key-values pairs
   *
   * @param {Object} keyValues Dictionary of key-value pairs
   * @param {String} customField Custom field name
   */},{key:"publishCustomDataKV",value:function publishCustomDataKV(keyValues){var customField=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"0";this.logger.info("Publishing custom data key-values for robot ".concat(this.robotId," ").concat(JSON.stringify(keyValues)));function convertValue(val){return(0,_typeof2["default"])(val)=="object"?JSON.stringify(val):String(val)}// Build protobuf message
var msg=new _inorbit_pb["default"].CustomDataMessage;msg.setCustomField(customField);var payload=new _inorbit_pb["default"].KeyValuePairs;payload.setPairsList(Object.keys(keyValues).map(function(k){var item=new _inorbit_pb["default"].KeyValueCustomElement;item.setKey(k);item.setValue(convertValue(keyValues[k]));return item}));msg.setKeyValuePayload(payload);return this.publishProtobuf(MQTT_TOPIC_CUSTOM_DATA,msg)}/**
   * Publishes pose to InOrbit
   *
   * @param {number} ts Timestamp in milliseconds
   * @param {number} x
   * @param {number} y
   * @param {number} yaw Yaw in radians
   * @param {string} frameId Robot's reference frame id
   */},{key:"publishPose",value:function publishPose(_ref2){var ts=_ref2.ts,x=_ref2.x,y=_ref2.y,yaw=_ref2.yaw,frameId=_ref2.frameId;this.logger.info("Publishing pose ".concat(JSON.stringify({ts:ts,x:x,y:y,yaw:yaw,frameId:frameId})));var msg=new _inorbit_pb["default"].LocationAndPoseMessage;msg.setTs(ts);msg.setPosX(x);msg.setPosY(y);msg.setYaw(yaw);// TODO(mike) report frameId when we start using it
return this.publishProtobuf(MQTT_TOPIC_LOCALIZATION,msg)}/**
   * Publishes odometry data to InOrbit
   *
   * @typedef Speed
   * @property {number} linear Linear speed in m/s
   * @property {number} angular Angular speed in rad/s
   *
   * @typedef Distance
   * @property {number} linear Linear distance in m
   * @property {number} angular Angular distance in rad
   *
   * @param {number} tsStart when are you counting from.
   * @param {number} ts when the measurement was taken
   * @param {Speed} speed
   * @param {Distance} distance
   */},{key:"publishOdometry",value:function publishOdometry(_ref3){var tsStart=_ref3.tsStart,ts=_ref3.ts,_ref3$distance=_ref3.distance,distance=_ref3$distance===void 0?{linear:0,angular:0}:_ref3$distance,_ref3$speed=_ref3.speed,speed=_ref3$speed===void 0?{linear:0,angular:0}:_ref3$speed;this.logger.info("Publishing odometry ".concat(JSON.stringify({tsStart:tsStart,ts:ts,distance:distance,speed:speed})));var msg=new _inorbit_pb["default"].OdometryDataMessage;msg.setTsStart(tsStart);msg.setTs(ts);msg.setLinearDistance(distance.linear);msg.setAngularDistance(distance.angular);msg.setLinearSpeed(speed.linear);msg.setAngularSpeed(speed.angular);msg.setSpeedAvailable(true);return this.publishProtobuf(MQTT_TOPIC_ODOMETRY,msg)}/**
   * Publishes a Protocol Buffers message
   *
   * @param {string} topic
   * @param {Object} msg
   * @param {Object} options
   */},{key:"publishProtobuf",value:function publishProtobuf(topic,msg){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;return this.publish(topic,msg.serializeBinary(),options)}}]);return RobotSession}();/**
 * Builds RobotSession objects for a company
 */var RobotSessionFactory=/*#__PURE__*/function(){/**
   * Creates a RobotSession factory
   *
   * @typedef {Settings}
   * @property {string} appKey Company app key
   * @property {string} endpoint URL of the HTTP endpoint to fetch
   * robots settings.
   *
   * @param {Settings} robotSessionSettings
   */function RobotSessionFactory(robotSessionSettings){(0,_classCallCheck2["default"])(this,RobotSessionFactory);this.robotSessionSettings=robotSessionSettings}/**
   * Builds a RobotSession for a robot
   *
   * @param {string} robotId
   * @param {string} name
   * @returns {RobotSession}
   */(0,_createClass2["default"])(RobotSessionFactory,[{key:"build",value:function build(_ref4){var robotId=_ref4.robotId,name=_ref4.name;return new RobotSession({robotId:robotId,name:name},this.robotSessionSettings)}}]);return RobotSessionFactory}();/**
 * Pool of robot sessions that handles connections for many robots in an
 * efficient way.
 */var RobotSessionPool=/*#__PURE__*/function(){function RobotSessionPool(robotSessionFactory){(0,_classCallCheck2["default"])(this,RobotSessionPool);this.robotSessionFactory=robotSessionFactory;this.robotSessions={};this.robotSessionsLastUse={};this.connectPromises={}}/**
   * Returns a connected RobotSession for a robot.
   *
   * @param {string} robotId
   * @param {string} name
   * @returns RobotSession
   */(0,_createClass2["default"])(RobotSessionPool,[{key:"getSession",value:function(){var _getSession=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref5){var robotId,name;return _regenerator["default"].wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:robotId=_ref5.robotId,name=_ref5.name;this.robotSessionsLastUse[robotId]=Date.now();if(!this.robotSessions[robotId]){this.robotSessions[robotId]=this.robotSessionFactory.build({robotId:robotId,name:name});// This connectPromises guarantees that this method always returns a connected
// session, but it doesn't invoke RobotSession's connect more than once
this.connectPromises[robotId]=this.robotSessions[robotId].connect()}// Since we await for the connect before returning
_context3.next=5;return this.connectPromises[robotId];case 5:return _context3.abrupt("return",this.robotSessions[robotId]);case 6:case"end":return _context3.stop();}}},_callee3,this)}));function getSession(_x){return _getSession.apply(this,arguments)}return getSession}()/**
   * Ends all sessions
   */},{key:"tearDown",value:function tearDown(){Object.values(this.robotSessions).forEach(function(rs){return rs.end()});this.robotSessions={};this.robotSessionsLastUse={};this.connectPromises={}}/**
   * Returns if there is a robot session associated to the robotId
   * @param {string} robotId
   * @returns {boolean}
   */},{key:"hasRobot",value:function hasRobot(robotId){return robotId in this.robotSessions}/**
   * Disconnects and frees a robot session
   * @param {string} robotId
   */},{key:"freeRobotSession",value:function(){var _freeRobotSession=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee4(robotId){var sess;return _regenerator["default"].wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(this.hasRobot(robotId)){_context4.next=2;break}return _context4.abrupt("return");case 2:_context4.next=4;return this.getSession({robotId:robotId});case 4:sess=_context4.sent;sess.end();delete this.robotSessions[robotId];delete this.robotSessionsLastUse[robotId];delete this.connectPromises[robotId];case 9:case"end":return _context4.stop();}}},_callee4,this)}));function freeRobotSession(_x2){return _freeRobotSession.apply(this,arguments)}return freeRobotSession}()}]);return RobotSessionPool}();var Logger=/*#__PURE__*/function(){function Logger(){(0,_classCallCheck2["default"])(this,Logger)}(0,_createClass2["default"])(Logger,[{key:"info",value:function info(){}},{key:"warn",value:function warn(){}},{key:"error",value:function error(){}}]);return Logger}();exports.Logger=Logger;var _sessionsPool=/*#__PURE__*/new WeakMap;var _explicitConnect=/*#__PURE__*/new WeakMap;var _getRobotSession=/*#__PURE__*/new WeakSet;var InOrbit=/*#__PURE__*/function(){/**
   * Initializes the InOrbit
   *
   * @typedef Logger
   * @property
   *
   * @typedef Settings
   * @property {string} appKey The account's app key. Used for authentication.
   * @property {string} endpoint InOrbit endpoint URL. Default to https://api.inorbit.ai
   * @property {Logger} logger By default a no-op logger is used
   *
   * @param {Settings} settings
   */function InOrbit(){var settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};(0,_classCallCheck2["default"])(this,InOrbit);_classPrivateMethodInitSpec(this,_getRobotSession);_classPrivateFieldInitSpec(this,_sessionsPool,{writable:true,value:void 0});_classPrivateFieldInitSpec(this,_explicitConnect,{writable:true,value:void 0});var appKey=settings.appKey,_settings$endpoint=settings.endpoint,endpoint=_settings$endpoint===void 0?INORBIT_ENDPOINT_DEFAULT:_settings$endpoint,_settings$logger=settings.logger,logger=_settings$logger===void 0?new Logger:_settings$logger;if(!appKey){throw Error("InOrbit expects appKey as part of the settings")}var sessionsFactory=new RobotSessionFactory({appKey:appKey,endpoint:endpoint,logger:logger});(0,_classPrivateFieldSet2["default"])(this,_sessionsPool,new RobotSessionPool(sessionsFactory));(0,_classPrivateFieldSet2["default"])(this,_explicitConnect,settings.explicitConnect!==false)}/**
   * Opens a connection associated to a robot and returns the session object.
   *
   * @see connectRobot
   * @returns RobotSession
   */(0,_createClass2["default"])(InOrbit,[{key:"tearDown",value:/**
   * Frees all resources and connections used by this InOrbit object
   */function tearDown(){this.sessionsPool.tearDown()}/**
   * Marks a robot as online and initializes the connection. If a connection
   * is already open, it's reused. So, invoking this method multiple times for
   * the same robot will create just one connection.
   *
   * @param {string} robotId
   * @param {string} name Name of the robot. This name will be used as the robot's
   * name if it's the first time it connects to the platform.
   */},{key:"connectRobot",value:function(){var _connectRobot=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee5(_ref6){var robotId,_ref6$name,name;return _regenerator["default"].wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:robotId=_ref6.robotId,_ref6$name=_ref6.name,name=_ref6$name===void 0?"edge-sdk":_ref6$name;_context5.next=3;return(0,_classPrivateFieldGet2["default"])(this,_sessionsPool).getSession({robotId:robotId,name:name});case 3:case"end":return _context5.stop();}}},_callee5,this)}));function connectRobot(_x3){return _connectRobot.apply(this,arguments)}return connectRobot}()/**
   * Marks a robot as offline and frees the connection.
   *
   * @param {string} robotId
   */},{key:"disconnectRobot",value:function(){var _disconnectRobot=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee6(robotId){return _regenerator["default"].wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return(0,_classPrivateFieldGet2["default"])(this,_sessionsPool).freeRobotSession(robotId);case 2:case"end":return _context6.stop();}}},_callee6,this)}));function disconnectRobot(_x4){return _disconnectRobot.apply(this,arguments)}return disconnectRobot}()/**
   * Publishes a a custom data message containing key-values pairs
   *
   * @param {string} robotId
   * @param {Object} keyValues Dictionary of key-value pairs
   * @param {string} customField Custom field name
   */},{key:"publishCustomDataKV",value:function(){var _publishCustomDataKV=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee7(robotId,keyValues){var customField,sess,_args7=arguments;return _regenerator["default"].wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:customField=_args7.length>2&&_args7[2]!==undefined?_args7[2]:"0";_context7.next=3;return _classPrivateMethodGet(this,_getRobotSession,_getRobotSession2).call(this,{robotId:robotId});case 3:sess=_context7.sent;return _context7.abrupt("return",sess.publishCustomDataKV(keyValues,customField));case 5:case"end":return _context7.stop();}}},_callee7,this)}));function publishCustomDataKV(_x5,_x6){return _publishCustomDataKV.apply(this,arguments)}return publishCustomDataKV}()/**
   * Publishes pose to InOrbit
   *
   * @typedef StampedPose
   * @property {number} ts Timestamp in milliseconds
   * @property {number} x
   * @property {number} y
   * @property {number} yaw Yaw in radians
   * @property {string} frameId Robot's reference frame id
   *
   * @param {string} robotId Id of the robot
   * @param {StampedPose} pose Robot pose
   */},{key:"publishPose",value:function(){var _publishPose=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee8(robotId,pose){var sess;return _regenerator["default"].wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:_context8.next=2;return _classPrivateMethodGet(this,_getRobotSession,_getRobotSession2).call(this,{robotId:robotId});case 2:sess=_context8.sent;return _context8.abrupt("return",sess.publishPose(pose));case 4:case"end":return _context8.stop();}}},_callee8,this)}));function publishPose(_x7,_x8){return _publishPose.apply(this,arguments)}return publishPose}()/**
   * Publishes odometry data to InOrbit
   *
   * @typedef Speed
   * @property {number} linear Linear speed in m/s
   * @property {number} angular Angular speed in rad/s
   *
   * @typedef Distance
   * @property {number} linear Linear distance in m
   * @property {number} angular Angular distance in rad
   *
   * @typedef StampedOdometry
   * @property {number} tsStart when are you counting from.
   * @property {number} ts when the measurement was taken
   * @property {Distance} distance
   * @property {Speed} speed
   *
   * @param {string} robotId Id of the robot
   * @param {StampedOdometry} odometry Odometry data
   */},{key:"publishOdometry",value:function(){var _publishOdometry=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee9(robotId,odometry){var sess;return _regenerator["default"].wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return _classPrivateMethodGet(this,_getRobotSession,_getRobotSession2).call(this,{robotId:robotId});case 2:sess=_context9.sent;return _context9.abrupt("return",sess.publishOdometry(odometry));case 4:case"end":return _context9.stop();}}},_callee9,this)}));function publishOdometry(_x9,_x10){return _publishOdometry.apply(this,arguments)}return publishOdometry}()}]);return InOrbit}();exports.InOrbit=InOrbit;function _getRobotSession2(_x11){return _getRobotSession3.apply(this,arguments)}function _getRobotSession3(){_getRobotSession3=(0,_asyncToGenerator2["default"])(/*#__PURE__*/_regenerator["default"].mark(function _callee10(_ref7){var robotId,_ref7$name,name;return _regenerator["default"].wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:robotId=_ref7.robotId,_ref7$name=_ref7.name,name=_ref7$name===void 0?"edge-sdk":_ref7$name;if(!((0,_classPrivateFieldGet2["default"])(this,_explicitConnect)&&!(0,_classPrivateFieldGet2["default"])(this,_sessionsPool).hasRobot(robotId))){_context10.next=3;break}throw new Error("Can't get robot session or send data before connecting. Use connectRobot before sending any data");case 3:return _context10.abrupt("return",(0,_classPrivateFieldGet2["default"])(this,_sessionsPool).getSession({robotId:robotId,name:name}));case 4:case"end":return _context10.stop();}}},_callee10,this)}));return _getRobotSession3.apply(this,arguments)}
//# sourceMappingURL=index.js.map